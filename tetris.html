<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Neon Tetris</title>
  <style>
    :root {
      --bg-0: #070812;
      --bg-1: #0d1021;
      --panel: rgba(12, 17, 38, 0.72);
      --panel-border: rgba(58, 214, 255, 0.38);
      --text: #d8ecff;
      --muted: #89a7c8;
      --accent: #39d6ff;
      --accent-2: #ff4aa3;
      --shadow: 0 0 28px rgba(57, 214, 255, 0.35);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(120% 120% at 10% 0%, #111835 0%, #070812 62%, #03040a 100%);
      color: var(--text);
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      touch-action: none;
    }

    body {
      display: grid;
      place-items: center;
      padding: 14px;
    }

    .app {
      position: relative;
      width: min(1100px, 100%);
      height: min(860px, 100%);
      display: grid;
      grid-template-columns: minmax(240px, 300px) minmax(280px, 520px) minmax(240px, 300px);
      gap: 14px;
      align-items: stretch;
    }

    .panel {
      backdrop-filter: blur(8px);
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 18px;
      box-shadow: var(--shadow), inset 0 0 20px rgba(57, 214, 255, 0.06);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
    }

    .title {
      margin: 0;
      font-size: clamp(18px, 2.5vw, 26px);
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: #cfffff;
      text-shadow: 0 0 12px rgba(57, 214, 255, 0.8);
    }

    .stats {
      display: grid;
      gap: 8px;
      font-size: 14px;
    }

    .stat {
      display: flex;
      justify-content: space-between;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(95, 136, 255, 0.22);
      background: rgba(24, 35, 76, 0.28);
    }

    .stat b { color: #f4fbff; }
    .hint { color: var(--muted); font-size: 12px; line-height: 1.35; }

    .mini-wrap { display: grid; gap: 8px; }
    .mini-label {
      font-size: 12px;
      text-transform: uppercase;
      color: #b6dbff;
      letter-spacing: 1px;
    }

    .mini {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(95, 136, 255, 0.25);
      background: linear-gradient(180deg, rgba(11, 16, 35, 0.8), rgba(8, 11, 24, 0.85));
      image-rendering: pixelated;
    }

    .center {
      position: relative;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid rgba(57, 214, 255, 0.4);
      box-shadow: 0 0 32px rgba(57, 214, 255, 0.3), inset 0 0 36px rgba(57, 214, 255, 0.08);
      background: linear-gradient(180deg, #070b1d, #060812);
    }

    #game {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      user-select: none;
    }

    .touch-guide {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      font-size: 10px;
      text-transform: uppercase;
      color: rgba(215, 235, 255, 0.35);
      letter-spacing: 1px;
    }

    .touch-guide div {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 10px;
      border-right: 1px dashed rgba(130, 188, 255, 0.1);
    }

    .touch-guide div:last-child { border-right: none; }

    .controls button {
      width: 100%;
      border: 1px solid rgba(57, 214, 255, 0.4);
      background: linear-gradient(180deg, rgba(57, 214, 255, 0.23), rgba(57, 214, 255, 0.08));
      color: #e9fbff;
      padding: 10px;
      border-radius: 10px;
      font-weight: 700;
      letter-spacing: 0.4px;
      cursor: pointer;
    }

    .controls button:active { transform: translateY(1px); }
    .controls-row {
      display: grid;
      grid-template-columns: 1fr 92px;
      gap: 8px;
      align-items: center;
    }
    .controls-row button {
      width: 92px;
    }
    .volume {
      width: 100%;
      accent-color: #39d6ff;
      cursor: pointer;
    }
    .volume-label {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 2px;
      display: inline-block;
    }
    .mode-select {
      width: 100%;
      border: 1px solid rgba(57, 214, 255, 0.4);
      background: rgba(12, 20, 44, 0.9);
      color: #e9fbff;
      padding: 8px 10px;
      border-radius: 10px;
      font-weight: 700;
    }

    .overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      display: grid;
      place-items: center;
      font-size: clamp(22px, 3.5vw, 36px);
      font-weight: 800;
      text-transform: uppercase;
      color: #f8fdff;
      text-shadow: 0 0 14px rgba(255, 74, 163, 0.8), 0 0 24px rgba(57, 214, 255, 0.7);
      opacity: 0;
      transition: opacity 180ms ease;
      background: radial-gradient(circle at 50% 50%, rgba(11, 16, 34, 0.2), rgba(5, 6, 12, 0.75));
    }

    .overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    @media (max-width: 940px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: minmax(0, 1fr) auto auto;
        height: 100%;
      }
      .panel { padding: 10px; }
      .touch-guide { font-size: 9px; }
      .center { order: 1; min-height: 0; }
      .left-panel { order: 2; }
      .right-panel { order: 3; }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="panel left-panel">
      <h1 class="title">Neon Tetris</h1>
      <div class="stats">
        <div class="stat"><span>Score</span><b id="score">0</b></div>
        <div class="stat"><span>High Score</span><b id="high">0</b></div>
        <div class="stat"><span>Level</span><b id="level">1</b></div>
        <div class="stat"><span>Lines</span><b id="lines">0</b></div>
        <div class="stat"><span>Combo</span><b id="combo">0</b></div>
      </div>
      <div class="mini-wrap">
        <span class="mini-label">Hold (C / Swipe Up)</span>
        <canvas id="hold" class="mini" width="180" height="120"></canvas>
      </div>
      <div class="controls">
        <span class="volume-label">Mode</span>
        <select id="modeSelect" class="mode-select" aria-label="Game mode">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
          <option value="ultra">Ultra</option>
        </select>
        <button id="startBtn" type="button">Start Game</button>
        <button id="pauseBtn" type="button">Pause</button>
        <button id="restartBtn" type="button">Restart</button>
        <span class="volume-label">Sound</span>
        <div class="controls-row">
          <input id="volumeSlider" class="volume" type="range" min="0" max="100" step="1" value="80" aria-label="Sound volume" />
          <button id="muteBtn" type="button">Mute</button>
        </div>
      </div>
    </aside>

    <main class="center">
      <canvas id="game" width="540" height="960" aria-label="Tetris board"></canvas>
      <div class="touch-guide" aria-hidden="true">
        <div>Tap Left</div>
        <div>Tap Rotate</div>
        <div>Tap Right</div>
      </div>
      <div id="overlay" class="overlay">Paused</div>
    </main>

    <aside class="panel right-panel">
      <div class="mini-wrap">
        <span class="mini-label">Next Queue</span>
        <canvas id="next" class="mini" width="180" height="420"></canvas>
      </div>
      <div class="hint">
        Controls:<br />
        Arrow Left/Right: Move<br />
        Arrow Up / Z: Rotate CW / CCW<br />
        Arrow Down: Soft Drop<br />
        Space: Hard Drop<br />
        C: Hold<br />
        P: Pause/Resume<br />
        Touch: Tap/Swipe gestures enabled
      </div>
    </aside>
  </div>

  <script>
    (() => {
      "use strict";

      // --- Canvas + layout ---
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const holdCanvas = document.getElementById("hold");
      const holdCtx = holdCanvas.getContext("2d");
      const nextCanvas = document.getElementById("next");
      const nextCtx = nextCanvas.getContext("2d");
      const overlay = document.getElementById("overlay");

      const ui = {
        score: document.getElementById("score"),
        high: document.getElementById("high"),
        level: document.getElementById("level"),
        lines: document.getElementById("lines"),
        combo: document.getElementById("combo")
      };

      const COLS = 10;
      const ROWS = 20;
      const VISIBLE_ROWS = 20;
      let CELL = 48;
      let BOARD_X = 0;
      let BOARD_Y = 0;

      const STORAGE_KEY = "neon_tetris_high_score_v1";
      const AUDIO_VOLUME_KEY = "neon_tetris_volume_v1";
      const AUDIO_MUTE_KEY = "neon_tetris_mute_v1";

      const MODES = {
        easy:   { name: "Easy", gravityBase: 1150, gravityStep: 45, gravityMin: 120, lockDelay: 550, softDropMultiplier: 4, linesPerLevel: 14 },
        medium: { name: "Medium", gravityBase: 900,  gravityStep: 55, gravityMin: 65,  lockDelay: 450, softDropMultiplier: 6, linesPerLevel: 10 },
        hard:   { name: "Hard", gravityBase: 760,  gravityStep: 70, gravityMin: 45,  lockDelay: 360, softDropMultiplier: 8, linesPerLevel: 8 },
        ultra:  { name: "Ultra", gravityBase: 430,  gravityStep: 120, gravityMin: 14, lockDelay: 180, softDropMultiplier: 14, linesPerLevel: 4 }
      };

      const COLORS = {
        I: "#39d6ff",
        O: "#ffd85a",
        T: "#c663ff",
        S: "#4cff97",
        Z: "#ff5378",
        J: "#5e7bff",
        L: "#ff9c42"
      };

      const PIECES = {
        I: [
          [[0,1],[1,1],[2,1],[3,1]],
          [[2,0],[2,1],[2,2],[2,3]],
          [[0,2],[1,2],[2,2],[3,2]],
          [[1,0],[1,1],[1,2],[1,3]]
        ],
        O: [
          [[1,0],[2,0],[1,1],[2,1]],
          [[1,0],[2,0],[1,1],[2,1]],
          [[1,0],[2,0],[1,1],[2,1]],
          [[1,0],[2,0],[1,1],[2,1]]
        ],
        T: [
          [[1,0],[0,1],[1,1],[2,1]],
          [[1,0],[1,1],[2,1],[1,2]],
          [[0,1],[1,1],[2,1],[1,2]],
          [[1,0],[0,1],[1,1],[1,2]]
        ],
        S: [
          [[1,0],[2,0],[0,1],[1,1]],
          [[1,0],[1,1],[2,1],[2,2]],
          [[1,1],[2,1],[0,2],[1,2]],
          [[0,0],[0,1],[1,1],[1,2]]
        ],
        Z: [
          [[0,0],[1,0],[1,1],[2,1]],
          [[2,0],[1,1],[2,1],[1,2]],
          [[0,1],[1,1],[1,2],[2,2]],
          [[1,0],[0,1],[1,1],[0,2]]
        ],
        J: [
          [[0,0],[0,1],[1,1],[2,1]],
          [[1,0],[2,0],[1,1],[1,2]],
          [[0,1],[1,1],[2,1],[2,2]],
          [[1,0],[1,1],[0,2],[1,2]]
        ],
        L: [
          [[2,0],[0,1],[1,1],[2,1]],
          [[1,0],[1,1],[1,2],[2,2]],
          [[0,1],[1,1],[2,1],[0,2]],
          [[0,0],[1,0],[1,1],[1,2]]
        ]
      };

      const JLSTZ_KICKS = {
        "0>1": [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
        "1>0": [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
        "1>2": [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
        "2>1": [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
        "2>3": [[0,0],[1,0],[1,-1],[0,2],[1,2]],
        "3>2": [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
        "3>0": [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
        "0>3": [[0,0],[1,0],[1,1],[0,-2],[1,-2]]
      };

      const I_KICKS = {
        "0>1": [[0,0],[-2,0],[1,0],[-2,1],[1,-2]],
        "1>0": [[0,0],[2,0],[-1,0],[2,-1],[-1,2]],
        "1>2": [[0,0],[-1,0],[2,0],[-1,-2],[2,1]],
        "2>1": [[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
        "2>3": [[0,0],[2,0],[-1,0],[2,-1],[-1,2]],
        "3>2": [[0,0],[-2,0],[1,0],[-2,1],[1,-2]],
        "3>0": [[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
        "0>3": [[0,0],[-1,0],[2,0],[-1,-2],[2,1]]
      };

      const SCORE_TABLE = [0, 100, 300, 500, 800];

      const game = {
        board: [],
        bag: [],
        queue: [],
        active: null,
        hold: null,
        canHold: true,
        score: 0,
        level: 1,
        lines: 0,
        combo: -1,
        mode: "medium",
        started: false,
        highScore: Number(localStorage.getItem(STORAGE_KEY) || 0),
        paused: false,
        over: false,
        dropAccumulator: 0,
        lastTime: 0,
        clearRows: null,
        clearTimer: 0,
        particles: [],
        shake: 0,
        lockTimer: 0
      };

      const input = {
        left: false,
        right: false,
        down: false,
        leftDas: 0,
        rightDas: 0,
        dasDelay: 140,
        arrDelay: 40
      };

      const audio = {
        ctx: null,
        masterGain: null,
        ready: false,
        volume: Math.max(0, Math.min(1, Number(localStorage.getItem(AUDIO_VOLUME_KEY) || 0.8))),
        muted: localStorage.getItem(AUDIO_MUTE_KEY) === "1"
      };

      function initAudio() {
        if (audio.ready) {
          if (audio.ctx && audio.ctx.state === "suspended") audio.ctx.resume();
          return;
        }
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) return;
        audio.ctx = new AudioContext();
        audio.masterGain = audio.ctx.createGain();
        audio.masterGain.connect(audio.ctx.destination);
        applyAudioSettings();
        audio.ready = true;
      }

      function applyAudioSettings() {
        if (!audio.masterGain || !audio.ctx) return;
        const gainValue = audio.muted ? 0 : audio.volume;
        audio.masterGain.gain.setTargetAtTime(gainValue, audio.ctx.currentTime, 0.01);
      }

      function setVolumeFromSlider(value) {
        audio.volume = Math.max(0, Math.min(1, Number(value) / 100));
        localStorage.setItem(AUDIO_VOLUME_KEY, String(audio.volume));
        if (audio.volume > 0 && audio.muted) {
          audio.muted = false;
          localStorage.setItem(AUDIO_MUTE_KEY, "0");
        }
        applyAudioSettings();
        syncAudioUi();
      }

      function toggleMute() {
        audio.muted = !audio.muted;
        localStorage.setItem(AUDIO_MUTE_KEY, audio.muted ? "1" : "0");
        applyAudioSettings();
        syncAudioUi();
      }

      function syncAudioUi() {
        const slider = document.getElementById("volumeSlider");
        const muteBtn = document.getElementById("muteBtn");
        slider.value = String(Math.round(audio.volume * 100));
        muteBtn.textContent = audio.muted ? "Unmute" : "Mute";
      }

      function syncPauseUi() {
        const pauseBtn = document.getElementById("pauseBtn");
        pauseBtn.textContent = game.paused ? "Resume" : "Pause";
      }

      function beep(freq = 440, dur = 0.05, type = "square", vol = 0.03, slide = 0) {
        if (!audio.ready || !audio.ctx || !audio.masterGain) return;
        const t0 = audio.ctx.currentTime;
        const o = audio.ctx.createOscillator();
        const g = audio.ctx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, t0);
        if (slide) o.frequency.linearRampToValueAtTime(freq + slide, t0 + dur);
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
        o.connect(g);
        g.connect(audio.masterGain);
        o.start(t0);
        o.stop(t0 + dur + 0.02);
      }

      function sfxMove() { beep(220, 0.03, "square", 0.015, 24); }
      function sfxRotate() { beep(510, 0.05, "triangle", 0.018, -100); }
      function sfxDrop() { beep(140, 0.05, "sawtooth", 0.03, -40); }
      function sfxLine() { beep(670, 0.09, "triangle", 0.05, 110); }
      function sfxTetris() {
        beep(420, 0.07, "triangle", 0.04, 60);
        setTimeout(() => beep(620, 0.08, "triangle", 0.045, 140), 60);
      }
      function sfxGameOver() {
        beep(220, 0.13, "sawtooth", 0.05, -180);
        setTimeout(() => beep(160, 0.18, "square", 0.045, -140), 80);
      }

      function resize() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.floor(rect.width);
        canvas.height = Math.floor(rect.height);

        const boardW = Math.min(rect.width * 0.78, rect.height * 0.54);
        CELL = Math.floor(boardW / COLS);
        const boardPixelW = CELL * COLS;
        const boardPixelH = CELL * VISIBLE_ROWS;
        BOARD_X = Math.floor((rect.width - boardPixelW) / 2);
        BOARD_Y = Math.floor((rect.height - boardPixelH) / 2);
      }

      function createBoard() {
        return Array.from({ length: ROWS }, () => Array(COLS).fill(null));
      }

      function shuffledBag() {
        const items = ["I", "O", "T", "S", "Z", "J", "L"];
        for (let i = items.length - 1; i > 0; i--) {
          const j = (Math.random() * (i + 1)) | 0;
          [items[i], items[j]] = [items[j], items[i]];
        }
        return items;
      }

      function refillQueue() {
        while (game.queue.length < 10) {
          if (game.bag.length === 0) game.bag = shuffledBag();
          game.queue.push(game.bag.shift());
        }
      }

      function getCells(piece) {
        return PIECES[piece.type][piece.rot].map(([x, y]) => [piece.x + x, piece.y + y]);
      }

      function collides(piece) {
        for (const [x, y] of getCells(piece)) {
          if (x < 0 || x >= COLS || y >= ROWS) return true;
          if (y >= 0 && game.board[y][x]) return true;
        }
        return false;
      }

      function spawnPiece(type = null) {
        refillQueue();
        const pieceType = type || game.queue.shift();
        const piece = {
          type: pieceType,
          x: 3,
          y: -1,
          rot: 0,
          visualY: -1
        };

        if (piece.type === "O") piece.x = 3;
        if (piece.type === "I") piece.x = 3;

        if (collides(piece)) {
          game.over = true;
          game.paused = false;
          overlay.textContent = "Game Over";
          overlay.classList.add("show");
          sfxGameOver();
          saveHighScore();
          return;
        }

        game.active = piece;
        game.canHold = true;
        game.lockTimer = 0;
      }

      function tryMove(dx, dy) {
        if (!game.active || game.clearRows || game.paused || game.over) return false;
        const next = { ...game.active, x: game.active.x + dx, y: game.active.y + dy };
        if (!collides(next)) {
          game.active.x = next.x;
          game.active.y = next.y;
          if (dy !== 0) game.active.visualY = Math.min(game.active.visualY, game.active.y);
          game.lockTimer = 0;
          return true;
        }
        return false;
      }

      function rotate(dir) {
        if (!game.active || game.clearRows || game.paused || game.over) return;
        const from = game.active.rot;
        const to = (from + dir + 4) % 4;
        const key = `${from}>${to}`;
        const kicks = game.active.type === "I" ? I_KICKS[key] : JLSTZ_KICKS[key];

        for (const [kx, ky] of kicks || [[0, 0]]) {
          const test = {
            ...game.active,
            rot: to,
            x: game.active.x + kx,
            y: game.active.y + ky
          };
          if (!collides(test)) {
            game.active.rot = to;
            game.active.x = test.x;
            game.active.y = test.y;
            game.lockTimer = 0;
            sfxRotate();
            return;
          }
        }
      }

      function hardDrop() {
        if (!game.active || game.paused || game.over || game.clearRows) return;
        let dist = 0;
        while (tryMove(0, 1)) dist++;
        game.score += dist * 2;
        lockPiece(true);
        sfxDrop();
      }

      function hold() {
        if (!game.active || !game.canHold || game.paused || game.over || game.clearRows) return;
        const current = game.active.type;
        if (game.hold) {
          const swap = game.hold;
          game.hold = current;
          spawnPiece(swap);
        } else {
          game.hold = current;
          spawnPiece();
        }
        game.canHold = false;
      }

      function getGhostY() {
        if (!game.active) return 0;
        const ghost = { ...game.active };
        while (!collides({ ...ghost, y: ghost.y + 1 })) ghost.y += 1;
        return ghost.y;
      }

      function lockPiece(fromHardDrop = false) {
        if (!game.active) return;

        for (const [x, y] of getCells(game.active)) {
          if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
            game.board[y][x] = game.active.type;
          }
        }

        const rows = [];
        for (let y = 0; y < ROWS; y++) {
          let full = true;
          for (let x = 0; x < COLS; x++) {
            if (!game.board[y][x]) { full = false; break; }
          }
          if (full) rows.push(y);
        }

        if (rows.length > 0) {
          game.clearRows = rows;
          game.clearTimer = 0.18;
          spawnClearParticles(rows);

          const points = SCORE_TABLE[rows.length] * game.level;
          game.score += points;
          game.lines += rows.length;
          game.combo += 1;
          if (game.combo > 0) game.score += game.combo * 50 * game.level;
          const mode = MODES[game.mode] || MODES.medium;
          game.level = Math.min(20, Math.floor(game.lines / mode.linesPerLevel) + 1);

          if (rows.length === 4) {
            game.shake = 16;
            sfxTetris();
          } else {
            sfxLine();
          }
        } else {
          game.combo = -1;
          if (!fromHardDrop) sfxDrop();
          spawnPiece();
        }

        saveHighScore();
        updateUi();
      }

      function finalizeClear() {
        if (!game.clearRows) return;
        const clearSet = new Set(game.clearRows);
        const newBoard = [];
        for (let y = 0; y < ROWS; y++) {
          if (!clearSet.has(y)) newBoard.push(game.board[y]);
        }
        while (newBoard.length < ROWS) newBoard.unshift(Array(COLS).fill(null));
        game.board = newBoard;
        game.clearRows = null;
        spawnPiece();
      }

      function spawnClearParticles(rows) {
        for (const y of rows) {
          for (let i = 0; i < 22; i++) {
            const px = BOARD_X + Math.random() * (COLS * CELL);
            const py = BOARD_Y + y * CELL + Math.random() * CELL;
            const angle = Math.random() * Math.PI * 2;
            const speed = 70 + Math.random() * 180;
            game.particles.push({
              x: px,
              y: py,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 0.45 + Math.random() * 0.25,
              maxLife: 0.55 + Math.random() * 0.3,
              color: `hsl(${185 + Math.random() * 110}, 100%, ${62 + Math.random() * 25}%)`
            });
          }
        }
      }

      function gravityInterval() {
        const mode = MODES[game.mode] || MODES.medium;
        return Math.max(mode.gravityMin, mode.gravityBase - (game.level - 1) * mode.gravityStep);
      }

      function softDrop() {
        if (tryMove(0, 1)) {
          game.score += 1;
          updateUi();
        }
      }

      function update(dt) {
        if (game.paused || game.over || !game.started) return;

        for (let i = game.particles.length - 1; i >= 0; i--) {
          const p = game.particles[i];
          p.life -= dt;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 260 * dt;
          p.vx *= 0.985;
          if (p.life <= 0) game.particles.splice(i, 1);
        }

        if (game.shake > 0) game.shake = Math.max(0, game.shake - 45 * dt);

        if (game.clearRows) {
          game.clearTimer -= dt;
          if (game.clearTimer <= 0) finalizeClear();
          return;
        }

        if (!game.active) return;

        game.active.visualY += (game.active.y - game.active.visualY) * Math.min(1, dt * 22);

        if (input.left) {
          input.leftDas -= dt * 1000;
          if (input.leftDas <= 0) {
            if (tryMove(-1, 0)) sfxMove();
            input.leftDas = input.arrDelay;
          }
        }
        if (input.right) {
          input.rightDas -= dt * 1000;
          if (input.rightDas <= 0) {
            if (tryMove(1, 0)) sfxMove();
            input.rightDas = input.arrDelay;
          }
        }

        const g = gravityInterval();
        game.dropAccumulator += dt * 1000;
        const mode = MODES[game.mode] || MODES.medium;
        const speedMultiplier = input.down ? mode.softDropMultiplier : 1;

        while (game.dropAccumulator >= g / speedMultiplier) {
          game.dropAccumulator -= g / speedMultiplier;
          if (!tryMove(0, 1)) {
            game.lockTimer += g / speedMultiplier;
            if (game.lockTimer >= mode.lockDelay) {
              lockPiece();
              break;
            }
          } else {
            game.lockTimer = 0;
            if (input.down) game.score += 1;
          }
        }

        updateUi();
      }

      function drawGrid() {
        const w = COLS * CELL;
        const h = VISIBLE_ROWS * CELL;

        const grad = ctx.createLinearGradient(BOARD_X, BOARD_Y, BOARD_X, BOARD_Y + h);
        grad.addColorStop(0, "rgba(9,14,36,0.95)");
        grad.addColorStop(1, "rgba(4,6,18,0.98)");
        ctx.fillStyle = grad;
        ctx.fillRect(BOARD_X, BOARD_Y, w, h);

        ctx.strokeStyle = "rgba(70,120,220,0.16)";
        ctx.lineWidth = 1;
        for (let x = 0; x <= COLS; x++) {
          const px = BOARD_X + x * CELL + 0.5;
          ctx.beginPath();
          ctx.moveTo(px, BOARD_Y);
          ctx.lineTo(px, BOARD_Y + h);
          ctx.stroke();
        }
        for (let y = 0; y <= VISIBLE_ROWS; y++) {
          const py = BOARD_Y + y * CELL + 0.5;
          ctx.beginPath();
          ctx.moveTo(BOARD_X, py);
          ctx.lineTo(BOARD_X + w, py);
          ctx.stroke();
        }

        ctx.strokeStyle = "rgba(57,214,255,0.5)";
        ctx.lineWidth = 2;
        ctx.strokeRect(BOARD_X, BOARD_Y, w, h);
      }

      function drawBlock(x, y, type, alpha = 1, ghost = false) {
        const px = BOARD_X + x * CELL;
        const py = BOARD_Y + y * CELL;
        if (y < 0) return;

        if (ghost) {
          ctx.fillStyle = `rgba(140,220,255,${0.11 * alpha})`;
          ctx.strokeStyle = "rgba(160,230,255,0.5)";
          ctx.lineWidth = 1.5;
          ctx.fillRect(px + 2, py + 2, CELL - 4, CELL - 4);
          ctx.strokeRect(px + 2.5, py + 2.5, CELL - 5, CELL - 5);
          return;
        }

        const color = COLORS[type] || "#fff";
        ctx.save();
        ctx.globalAlpha = alpha;

        ctx.shadowColor = color;
        ctx.shadowBlur = CELL * 0.35;

        const g = ctx.createLinearGradient(px, py, px + CELL, py + CELL);
        g.addColorStop(0, shade(color, 24));
        g.addColorStop(1, shade(color, -18));
        ctx.fillStyle = g;
        ctx.fillRect(px + 1.5, py + 1.5, CELL - 3, CELL - 3);

        ctx.shadowBlur = 0;
        ctx.strokeStyle = "rgba(255,255,255,0.38)";
        ctx.lineWidth = 1;
        ctx.strokeRect(px + 1.5, py + 1.5, CELL - 3, CELL - 3);

        ctx.fillStyle = "rgba(255,255,255,0.22)";
        ctx.fillRect(px + 4, py + 4, CELL - 12, Math.max(3, CELL * 0.18));

        ctx.restore();
      }

      function drawBoard() {
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            const cell = game.board[y][x];
            if (!cell) continue;

            let alpha = 1;
            if (game.clearRows && game.clearRows.includes(y)) {
              const t = Math.max(0, game.clearTimer / 0.18);
              alpha = 0.2 + Math.sin((1 - t) * 35) * 0.2 + t;
            }
            drawBlock(x, y, cell, alpha);
          }
        }
      }

      function drawActive() {
        if (!game.active || game.clearRows) return;

        const ghostY = getGhostY();
        const ghostPiece = { ...game.active, y: ghostY };
        for (const [x, y] of getCells(ghostPiece)) drawBlock(x, y, game.active.type, 1, true);

        const visPiece = { ...game.active, y: game.active.visualY };
        for (const [lx, ly] of PIECES[visPiece.type][visPiece.rot]) {
          const x = visPiece.x + lx;
          const y = visPiece.y + ly;
          drawBlock(x, y, visPiece.type, 1, false);
        }
      }

      function drawParticles() {
        for (const p of game.particles) {
          const a = Math.max(0, p.life / p.maxLife);
          ctx.fillStyle = p.color;
          ctx.globalAlpha = a;
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 12;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 1.5 + (1 - a) * 2, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
      }

      function drawBackgroundFx(t) {
        const rect = canvas.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;

        ctx.fillStyle = "rgba(5,7,18,0.28)";
        ctx.fillRect(0, 0, w, h);

        const pulse = 0.2 + 0.1 * Math.sin(t * 0.0018);
        const grad = ctx.createRadialGradient(
          w * 0.5,
          h * 0.2,
          40,
          w * 0.5,
          h * 0.2,
          h * 0.7
        );
        grad.addColorStop(0, `rgba(57,214,255,${0.14 + pulse})`);
        grad.addColorStop(1, "rgba(57,214,255,0)");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
      }

      function drawMini(ctxMini, width, height, pieces, labelCount) {
        ctxMini.clearRect(0, 0, width, height);
        ctxMini.fillStyle = "rgba(8, 12, 28, 0.94)";
        ctxMini.fillRect(0, 0, width, height);

        const cell = Math.floor(Math.min(width / 6, height / (labelCount * 4.5)));
        for (let i = 0; i < pieces.length; i++) {
          const type = pieces[i];
          if (!type) continue;
          const shape = PIECES[type][0];
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const [x, y] of shape) {
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }
          const sx = (maxX - minX + 1) * cell;
          const sy = (maxY - minY + 1) * cell;
          const ox = Math.floor((width - sx) / 2 - minX * cell);
          const oy = Math.floor(i * (height / labelCount) + ((height / labelCount) - sy) / 2 - minY * cell);

          for (const [x, y] of shape) {
            const px = ox + x * cell;
            const py = oy + y * cell;
            ctxMini.save();
            ctxMini.shadowColor = COLORS[type];
            ctxMini.shadowBlur = 9;
            const g = ctxMini.createLinearGradient(px, py, px + cell, py + cell);
            g.addColorStop(0, shade(COLORS[type], 18));
            g.addColorStop(1, shade(COLORS[type], -14));
            ctxMini.fillStyle = g;
            ctxMini.fillRect(px + 1, py + 1, cell - 2, cell - 2);
            ctxMini.restore();
          }
        }
      }

      function render(time = 0) {
        const w = canvas.width;
        const h = canvas.height;
        const shakeX = game.shake > 0 ? (Math.random() - 0.5) * game.shake : 0;
        const shakeY = game.shake > 0 ? (Math.random() - 0.5) * game.shake : 0;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, w, h);
        ctx.translate(shakeX, shakeY);

        drawBackgroundFx(time);
        drawGrid();
        drawBoard();
        drawActive();
        drawParticles();

        drawMini(holdCtx, holdCanvas.width, holdCanvas.height, [game.hold], 1);
        drawMini(nextCtx, nextCanvas.width, nextCanvas.height, game.queue.slice(0, 5), 5);
      }

      function shade(hex, percent) {
        const f = parseInt(hex.slice(1), 16);
        const t = percent < 0 ? 0 : 255;
        const p = Math.abs(percent) / 100;
        const R = f >> 16;
        const G = (f >> 8) & 0x00ff;
        const B = f & 0x0000ff;
        const toHex = (n) => (`0${Math.round((t - n) * p + n).toString(16)}`).slice(-2);
        return `#${toHex(R)}${toHex(G)}${toHex(B)}`;
      }

      function updateUi() {
        if (game.score > game.highScore) {
          game.highScore = game.score;
          localStorage.setItem(STORAGE_KEY, String(game.highScore));
        }
        ui.score.textContent = String(game.score);
        ui.high.textContent = String(game.highScore);
        ui.level.textContent = String(game.level);
        ui.lines.textContent = String(game.lines);
        ui.combo.textContent = String(Math.max(0, game.combo));
      }

      function saveHighScore() {
        if (game.score > game.highScore) {
          game.highScore = game.score;
          localStorage.setItem(STORAGE_KEY, String(game.highScore));
        }
      }

      function resetGame() {
        game.board = createBoard();
        game.bag = [];
        game.queue = [];
        game.active = null;
        game.hold = null;
        game.canHold = true;
        game.score = 0;
        game.level = 1;
        game.lines = 0;
        game.combo = -1;
        game.started = false;
        game.paused = false;
        game.over = false;
        game.dropAccumulator = 0;
        game.clearRows = null;
        game.clearTimer = 0;
        game.particles = [];
        game.shake = 0;
        game.lockTimer = 0;
        refillQueue();
        overlay.textContent = "Press Start";
        overlay.classList.add("show");
        syncPauseUi();
        updateUi();
      }

      function startGame() {
        if (game.started || game.over) return;
        game.started = true;
        game.paused = false;
        game.dropAccumulator = 0;
        game.lastTime = 0;
        overlay.classList.remove("show");
        overlay.textContent = "";
        syncPauseUi();
        if (!game.active) spawnPiece();
      }

      function togglePause() {
        if (game.over || !game.started) return;
        game.paused = !game.paused;
        overlay.textContent = game.paused ? "Paused" : "";
        overlay.classList.toggle("show", game.paused);
        syncPauseUi();
      }

      function onKeyDown(e) {
        initAudio();

        if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Space", "KeyZ", "KeyC", "KeyP"].includes(e.code)) {
          e.preventDefault();
        }

        if (e.code === "KeyP") {
          if (!game.started && !game.over) {
            startGame();
            return;
          }
          return togglePause();
        }
        if (!game.started) {
          if (e.code === "Enter" || e.code === "Space") startGame();
          return;
        }
        if (game.paused || game.over) {
          if (game.over && e.code === "Enter") resetGame();
          return;
        }

        switch (e.code) {
          case "ArrowLeft":
            if (!input.left) {
              if (tryMove(-1, 0)) sfxMove();
              input.leftDas = input.dasDelay;
            }
            input.left = true;
            input.right = false;
            break;
          case "ArrowRight":
            if (!input.right) {
              if (tryMove(1, 0)) sfxMove();
              input.rightDas = input.dasDelay;
            }
            input.right = true;
            input.left = false;
            break;
          case "ArrowDown":
            input.down = true;
            break;
          case "ArrowUp":
            rotate(1);
            break;
          case "KeyZ":
            rotate(-1);
            break;
          case "Space":
            hardDrop();
            break;
          case "KeyC":
            hold();
            break;
          default:
            break;
        }
      }

      function onKeyUp(e) {
        if (e.code === "ArrowLeft") input.left = false;
        if (e.code === "ArrowRight") input.right = false;
        if (e.code === "ArrowDown") input.down = false;
      }

      // --- Touch controls ---
      let touchState = {
        active: false,
        id: null,
        startX: 0,
        startY: 0,
        lastX: 0,
        lastY: 0,
        startTime: 0,
        twoFingerStart: 0,
        consumed: false
      };

      function gameCoordsFromTouch(touch) {
        const r = canvas.getBoundingClientRect();
        return {
          x: touch.clientX - r.left,
          y: touch.clientY - r.top,
          w: r.width,
          h: r.height
        };
      }

      function touchStart(e) {
        initAudio();
        e.preventDefault();

        if (e.touches.length === 2) {
          touchState.twoFingerStart = performance.now();
          touchState.consumed = false;
          return;
        }

        if (e.touches.length !== 1) return;
        const t = e.touches[0];
        const p = gameCoordsFromTouch(t);
        touchState.active = true;
        touchState.id = t.identifier;
        touchState.startX = p.x;
        touchState.startY = p.y;
        touchState.lastX = p.x;
        touchState.lastY = p.y;
        touchState.startTime = performance.now();
        touchState.consumed = false;
      }

      function touchMove(e) {
        e.preventDefault();
        if (!touchState.active || game.paused || game.over || !game.started) return;

        const touch = [...e.touches].find(t => t.identifier === touchState.id);
        if (!touch) return;
        const p = gameCoordsFromTouch(touch);

        const dy = p.y - touchState.lastY;
        const totalDy = p.y - touchState.startY;

        if (dy > 6) {
          softDrop();
          touchState.consumed = true;
        }

        if (Math.abs(totalDy) > 18) touchState.consumed = true;

        touchState.lastX = p.x;
        touchState.lastY = p.y;
      }

      function touchEnd(e) {
        e.preventDefault();

        if (game.paused || game.over || !game.started) {
          touchState.active = false;
          return;
        }

        if (touchState.twoFingerStart && e.changedTouches.length <= 2 && e.touches.length === 0) {
          const dt = performance.now() - touchState.twoFingerStart;
          if (dt < 250) {
            rotate(-1);
          }
          touchState.twoFingerStart = 0;
        }

        const changed = [...e.changedTouches].find(t => t.identifier === touchState.id);
        if (!changed || !touchState.active) return;

        const p = gameCoordsFromTouch(changed);
        const dt = Math.max(1, performance.now() - touchState.startTime);
        const dx = p.x - touchState.startX;
        const dy = p.y - touchState.startY;
        const vy = dy / dt;

        const absDx = Math.abs(dx);
        const absDy = Math.abs(dy);

        if (dy < -48 && absDy > absDx + 10) {
          hold();
        } else if (dy > 70 && vy > 0.75) {
          hardDrop();
        } else if (!touchState.consumed && absDx < 24 && absDy < 24) {
          const zone = p.x / p.w;
          if (zone < 0.33) {
            if (tryMove(-1, 0)) sfxMove();
          } else if (zone > 0.66) {
            if (tryMove(1, 0)) sfxMove();
          } else {
            rotate(1);
          }
        }

        touchState.active = false;
        touchState.id = null;
      }

      function touchCancel(e) {
        e.preventDefault();
        touchState.active = false;
        touchState.id = null;
      }

      function loop(time) {
        if (!game.lastTime) game.lastTime = time;
        const dt = Math.min(0.033, (time - game.lastTime) / 1000);
        game.lastTime = time;

        update(dt);
        render(time);

        requestAnimationFrame(loop);
      }

      function init() {
        resize();
        updateUi();
        syncAudioUi();
        document.getElementById("modeSelect").value = game.mode;
        resetGame();

        window.addEventListener("resize", resize);
        window.addEventListener("keydown", onKeyDown, { passive: false });
        window.addEventListener("keyup", onKeyUp);

        canvas.addEventListener("touchstart", touchStart, { passive: false });
        canvas.addEventListener("touchmove", touchMove, { passive: false });
        canvas.addEventListener("touchend", touchEnd, { passive: false });
        canvas.addEventListener("touchcancel", touchCancel, { passive: false });

        document.getElementById("restartBtn").addEventListener("click", () => {
          initAudio();
          resetGame();
        });
        document.getElementById("startBtn").addEventListener("click", () => {
          initAudio();
          startGame();
        });
        document.getElementById("pauseBtn").addEventListener("click", () => {
          togglePause();
        });
        document.getElementById("modeSelect").addEventListener("change", (e) => {
          game.mode = e.target.value in MODES ? e.target.value : "medium";
          resetGame();
        });
        document.getElementById("volumeSlider").addEventListener("input", (e) => {
          initAudio();
          setVolumeFromSlider(e.target.value);
        });
        document.getElementById("muteBtn").addEventListener("click", () => {
          initAudio();
          toggleMute();
        });

        overlay.addEventListener("click", () => {
          if (!game.over) togglePause();
        });

        requestAnimationFrame(loop);
      }

      init();
    })();
  </script>
</body>
</html>
